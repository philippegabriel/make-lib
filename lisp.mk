#See: http://www.paulgraham.com/rootsoflisp.html
#support functions
lp:=(
rp:=)
space :=
space +=
expandl=$(subst $(lp), $(lp) ,$(1))
expandr=$(subst $(rp), $(rp) ,$(1))
expand=$(strip $(call expandr,$(call expandl,$(1))))
contractl=$(subst $(lp)$(space),$(lp),$(1))
contractr=$(subst $(space)$(rp),$(rp),$(1))
contract=$(strip $(call contractr,$(call contractl,$(1))))
dec=$(wordlist 2,$(words $(1)),$(1))
numinc=$(words $(1) .)
numdec=$(words $(call dec,$(1)))
getlist=$(if $(1),$(if $(filter $(word $(words $(3) .),$(2)),$(rp)),$(call getlist,$(call dec,$(1)),$(2),$(3) .),$(if $(filter $(word $(words $(3) .),$(2)),$(lp)),$(call getlist,$(1) .,$(2),$(3) .),$(call getlist,$(1),$(2),$(3) .))),$(3))
getarg1=$(if $(filter $(word 1,$(1)),$(lp)),$(wordlist 1,$(words $(call getlist,.,$(1),.)),$(1)),$(word 1,$(1)))
getsubarg=$(if $(filter $(word 2,$(1)),$(lp)),$(wordlist 2,$(words $(call getlist,.,$(1),. .)),$(1)),$(word 2,$(1)))
inxsubarg1=$(words $(call getlist,.,$(1),. .))
inxsubarg2=$(words $(call getlist,.,$(1),. .) .)
inxarg1=$(if $(filter $(word 1,$(1)),$(lp)),$(words $(call getlist,.,$(1),.)),1)
getarg2=$(if $(filter $(word 1,$(1)),$(lp)),$(wordlist $(call numinc,$(call getlist,.,$(1),.)),$(words $(1)),$(1)),$(wordlist 2,$(words $(1)),$(1)))
inxarg2=$(if $(filter $(word 1,$(1)),$(lp)),$(call numinc,$(call getlist,.,$(1),.)),2)
#getarg2=$(if $(filter $(word 1,$(1)),$(lp)),$(call numinc,$(call getlist,.,$(1),.)) to $(words $(1)),$(word 2,$(1)))
get1st=$(wordlist 1,$(words $(call getlist,.,$(1),.)),$(1))
gettail=$(wordlist $(call numinc, $(call getlist,.,$(1),.)),$(words $(1)),$(1))
eqContent=$(and $(filter $(1),$(2)),$(filter $(2),$(1)),t)
len1=$(if $(filter $(words $(1)),1),t,)
len2=$(if $(filter $(words $(1)),2),t,)
len1or2=$(if $(filter $(words $(1)),1 2),t,)
len4=$(if $(filter $(words $(1)),4),t,)
#len1or2=$(or $(filter $(words $(1)),1),$(filter $(words $(1)),2))
Ist=$(call eqContent,$(1),t,)
#bootstrap eval for Sexpr
sevalparse=primitive:$(word 2,$(call expand,$(1))) arg:$(wordlist 3,$(call numdec,$(call expand,$(1))),$(call expand,$(1)))
seval=$(call $(word 2,$(call expand,$(1))),$(wordlist 3,$(call numdec,$(call expand,$(1))),$(call expand,$(1))))
#These are the 7 primitives implemented with make intrinsyc functions
quote=$(1)
atom=$(or $(call len1,$(call seval,$(1))),$(call len2,$(call seval,$(1))))
eq=$(if $(and $(call len1,$(call seval,$(call getarg1,$(1)))),$(call len1,$(call seval,$(call getarg2,$(1))))),$(call eqContent,$(call seval,$(call getarg1,$(1))),$(call seval,$(call getarg2,$(1)))),$(and $(call len2,$(call seval,$(call getarg1,$(1)))),$(call len2,$(call seval,$(call getarg2,$(1))))))
car=$(if $(filter $(word 2,$(call seval,$(1))),$(lp)),$(wordlist 2,$(words $(call getlist,.,$(call seval,$(1)),. .)),$(call seval,$(1))),$(word 2,$(call seval,$(1))))
cdr=$(lp) $(wordlist $(if $(filter $(word 2,$(call seval,$(1))),$(lp)),$(words $(call getlist,.,$(call seval,$(1)),. .) .),3),$(words $(call seval,$(1))),$(call seval,$(1)))
cons=$(lp) $(call seval,$(wordlist 1,$(call inxarg1,$(1)),$(1))) $(call dec,$(call seval,$(wordlist $(call inxarg2,$(1)),$(words $(1)),$(1))))
cadr=$(call seval,(car (cdr $(1))))
caddr=$(call car,$(call cdr,$(call cdr,$(1))))
caar=$(call car,$(call car,$(1)))
cdar=$(call cdr,$(call car,$(1)))
cddr=$(call cdr,$(call cdr,$(1)))
condparse=subarg1:[$(wordlist 2,$(call inxsubarg1,$(call getarg1,$(1))),$(1))],subarg2:[$(wordlist $(call inxsubarg2,$(call getarg1,$(1))),$(call numdec,$(call getarg1,$(1))),$(1))],tail:[$(call gettail,$(1))]
cond=$(if $(call seval,$(wordlist 2,$(call inxsubarg1,$(call getarg1,$(1))),$(1))),$(call seval,$(wordlist $(call inxsubarg2,$(call getarg1,$(1))),$(call numdec,$(call getarg1,$(1))),$(1))),$(call cond,$(call gettail,$(1))))
#
#
eval.=$(call contract,$(call evaln,$(call expand,$(1))))
evaln=$(call condparse,( $(call condcheck,$(1),quote) $(call evalquote,$(1)) ) ( t $(1) ) ) 
#evaln=$(call cond,( $(call condcheck,$(1),quote) $(call evalquote,$(1)) ) ( $(call condcheck,$(1),atom) $(call evalatom,$(1)) ) ( $(call condcheck,$(1),eq) $(call evaleq,$(1)) ) ( $(call condcheck,$(1),car) $(call evalcar,$(1)) ) ( $(call condcheck,$(1),cdr) $(call evalcdr,$(1)) ) ( $(call condcheck,$(1),cons) $(call evalcons,$(1)) ) ( t END ) )
condcheck=$(call eq,$(call car,$(1)),$(2))
evalquote=$(call cadr,$(1))
evalatom=$(or $(call atom,$(call evaln,$(call cadr,$(1)))),( ))
evaleq=$(or $(call eq,$(call evaln,$(call cadr,$(1))),$(call evaln,$(call caddr,$(1)))),( ))
evalcar=$(call car,$(call evaln,$(call cadr,$(1))))
evalcdr=$(call cdr,$(call evaln,$(call cadr,$(1))))
evalcons=$(call cons,$(call quote,$(call cadr,$(1))),$(call quote,$(call caddr,$(1))))
evaln=$(or $(if $(call atom,$(call car,$(1))),$(or $(call evalcar,$(1)),$(call evalcdr,$(1)),$(call evaleq,$(1)),$(call evalquote,$(1)),$(call evalatom,$(1)),$(call evalcons,$(1))),$(1)),$(1))
#evalquote=$(if $(call eq,$(call car,$(1)),quote),$(call cadr,$(1)),)
#evalatom=$(if $(call eq,$(call car,$(1)),atom),$(or $(call atom,$(call evaln,$(call cadr,$(1)))),( )),)
#evaleq=$(if $(call eq,$(call car,$(1)),eq),$(or $(call eq,$(call evaln,$(call cadr,$(1))),$(call evaln,$(call caddr,$(1)))),( )),)
#evalcar=$(if $(call eq,$(call car,$(1)),car),$(call car,$(call evaln,$(call cadr,$(1)))),)
#evalcdr=$(if $(call eq,$(call car,$(1)),cdr),$(call cdr,$(call evaln,$(call cadr,$(1)))),)
#evalcons=$(if $(call eq,$(call car,$(1)),cons),$(call cons,$(call quote,$(call cadr,$(1))),$(call quote,$(call caddr,$(1)))),)
all:
	@printf "expand,(a b c)=$(call expand,$(call expand,(a b c)))\n"
	@printf "(expand ((a b)(c d))=$(call expand,((a b)(c d)))\n"
	@printf "eqContent,a,b=>$(call eqContent,a,b)<\n"
	@printf "eqContent,a,a=>$(call eqContent,a,a)<\n"
	@printf "eqContent,aaaa,aaab=>$(call eqContent,aaaa,aaab)<\n"
	@printf "eqContent,( a b ),( a b ) =>$(call eqContent,( a b ),( a b ))<\n"
	@printf "dec, ..=>$(call dec, . . )<\n"
	@printf "dec, .=>$(call dec, . )<\n"
	@printf "numdec, . . .=>$(call numdec, . . .)<\n"
	@printf "getlist,.,( x ),.=>$(call getlist,.,( x ),.)<\n"
	@printf "getlist,., ( a b ),.=>$(call getlist,., ( a b ),.)<\n"
	@printf "getlist,.,( a b ( c ) d ) ( f g ),.=>$(call getlist,.,( a b ( c ) d ) e ( f g ) ,.)<\n"
	@printf "getlist,.,( (a b)(c d)) ),.=>$(call getlist,.,( ( a b ) ( c d ) ),.)<\n"
	@printf "inxarg1,a b=>$(call inxarg1,a b)<\n"
	@printf "inxarg1,(a b) c=>$(call inxarg1,( a b ) c)<\n"
	@printf "inxarg1,a (b c)=>$(call inxarg1,a ( b c ))<\n"
	@printf "inxarg1,(a b) (c d)=>$(call inxarg1,( a b ) ( c d ))<\n"
	@printf "inxarg2,a b=>$(call inxarg2,a b)<\n"
	@printf "inxarg2,(a b) c=>$(call inxarg2,( a b ) c)<\n"
	@printf "inxarg2,a (b c)=>$(call inxarg2,a ( b c ))<\n"
	@printf "inxarg2,(a b) (c d)=>$(call inxarg2,( a b ) ( c d ))<\n"
	@printf "(quote a)=>$(call seval,(quote a))<\n"
	@printf "(quote ())=>$(call seval,(quote ()))<\n"
	@printf "(quote (a b))=>$(call seval,(quote (a b)))<\n"
	@printf "(atom 'a)=>$(call seval,(atom (quote a)))<\n"
	@printf "(atom '())=>$(call seval,(atom (quote ())))<\n"
	@printf "(atom '(a b))=>$(call seval,(atom (quote (a b))))<\n"
	@printf "(car '(a b))=>$(call seval,(car (quote (a b))))<\n"
	@printf "(atom (car '(a b)))=>$(call seval,(atom (car (quote (a b)))))<\n"
	@printf "(car '((a b)(c d)))=>$(call seval,(car (quote ((a b)(c d)))))<\n"
	@printf "(atom (car '((a b)(c d))))=>$(call seval,(atom (car (quote ((a b)(c d))))))<\n"
	@printf "(car '(a b))=$(call seval,(car (quote (a b))))\n"
	@printf "(car '((a b)(c d))=$(call seval,(car (quote ((a b)(c d)))))\n"
	@printf "(cdr '(a b))=$(call seval,(cdr (quote (a b))))\n"
	@printf "(cdr '((a b)(c d))=$(call seval,(cdr (quote ((a b)(c d)))))\n"
	@printf "(cadr '((a b) (c d)))=$(call seval,(cadr (quote ((a b) (c d)))))\n"
	@printf "(cons 'a '(b c))=$(call seval,(cons (quote a) (quote (b c))))\n"
	@printf "(cons '(a b) '(c d))=$(call seval,(cons (quote (a b)) (quote (c d))))\n"
	@printf "(cons '() '(c d))=$(call seval,(cons (quote ()) (quote (c d))))\n"
	@printf "(eq 'a 'a) =>$(call seval,(eq (quote a) (quote a)))<\n"
	@printf "(eq 'a 'b) =>$(call seval,(eq (quote a) (quote b)))<\n"
	@printf "(eq 'atom 'atom) =>$(call seval,(eq (quote atom) (quote atom)))<\n"
	@printf "(eq '() '()) =>$(call seval,(eq (quote ()) (quote ())))<\n"
	@printf "(eq '(a b) '(a b)) =>$(call seval,(eq (quote (a b)) (quote (a b))))<\n"
	@printf "(getarg1 (f first)(t second))=$(call getarg1,$(call expand,(f first)(t second) ))\n"
	@printf "(getrest (f first)(t second))=$(call getrest,$(call expand,(f first)(t second) ))\n"
	@printf "(inxsubarg1 ((quote t) (quote first)))=$(call inxsubarg1,$(call expand,((quote t) (quote first))))\n"
	@printf "(condparse ('t 'first))=$(call seval,(condparse ((quote t) (quote first))))\n"
	@printf "(condparse ('t 'first) ('f 'second))=$(call seval,(condparse ((quote t) (quote first))((quote f)(quote second))))\n"
	@printf "(cond ('t 'first))=$(call seval,(cond ((quote t) (quote first))))\n"
sk:
	@printf "(cond ((eq 'a 'b) 'first)((atom 'a) 'second))=$(call condparse,$(call expand,(t first)))\n"
	@printf "(cond ((eq 'a 'b) 'first)((atom 'a) 'second))=$(call condparse,$(call expand,(f first)(t second) ))\n"
	@printf "(cond ('t 'first))=$(call cond,$(call expand,(t first)))\n"
	@printf "(cond ('f 'first)('t 'second))=$(call cond,$(call expand,(f first)(t second) ))\n"
	@printf "(cond ((eq 'a 'a) 'first)('t 'second))=$(call cond,$(call expand,((eq a a) first)(t second) ))\n"
	@printf "(cond ((eq 'a 'b) 'first)('t 'second))=$(call cond,$(call expand,((eq a b) first)(t second) ))\n"

rest:
	@printf "(eval  (a) )=$(call eval.,(a))\n"
	@printf "(eval (quote a))=$(call eval.,(quote a))\n"
	@printf "(eval (quote (a b)))=$(call eval.,(quote (a b)))\n"
	@printf "(eval (atom a))=>$(call eval.,(atom a))<\n"
	@printf "(eval (atom ()))=>$(call eval.,(atom ()))<\n"
	@printf "(eval (atom (a b)))=>$(call eval.,(atom (a b)))<\n"
	@printf "(eval (car ( a ) ))=$(call eval.,(car (a)))\n"
	@printf "(eval (car ( a b c) ))=$(call eval.,(car (a b c) ))\n"
	@printf "(eval (car ((a b)(c d))))=$(call eval.,(car ((a b) (c d))))\n"
	@printf "(eval (cdr ((a b)(c d))))=$(call eval.,(cdr ((a b) (c d))))\n"
	@printf "(eval (eq a a))=$(call eval.,(eq a a))\n"
	@printf "(eval (eq a b))=$(call eval.,(eq a b))\n"
	@printf "(eval (cons a (b c)))=$(call eval.,(cons a (b c)))\n"
	@printf "(eval (cons (a b) (c d)))=$(call eval.,(cons (a b) (c d)))\n"
	@printf "(eval (cons () (c d)))=$(call eval.,(cons () (c d)))\n"
	@printf "(car ((eq 'a 'b) 'first)((atom 'a) 'second))=$(call car,$(call expand,(((eq 'a 'b) 'first)((atom 'a) 'second)) ))\n"
	@printf "(cdr ((eq 'a 'b) 'first)((atom 'a) 'second))=$(call cdr,$(call expand,(((eq 'a 'b) 'first)((atom 'a) 'second)) ))\n"

